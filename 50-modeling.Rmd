---
title: "50-modeling"
output: html_document
---

The purpose of this document is to create the final models used for the exploration in the file 60 series.

```{r load libraries}
library(pacman)
pacman::p_load(tidyverse, testit)
```

The following function is used to split the data
```{r split data function}
# df: dataframe to split
# strat_var: outcome variable to split on.  Can be a string if desired, e.g., outcome='h5mn8' ...%>%split_data(outcome)
# ratios: a list of the ratios for 2 or 3 splits.  Each split requires a ratio (e.g., train+test requires two ratios)
# returns: a list of dfs entitled 'train, test', or 'train, valid, test' corresponding to the input ratios.
split_data <- function(df, strat_var, ratios=c(0.7,0.2,0.1)){
  
  #assertions
  testit::assert("sum of the ratios must be 1!" , sum(ratios)==1.0)
  
  #split data
  splits <- df %>%
      rsample::initial_split(strat = {{strat_var}}, prop = sum(ratios[-length(ratios)]))
  
  #get data splits
  train = rsample::training(splits)
  test = rsample::testing(splits)
  
  #create split list for 2 splits
  split_list <- list(train = train,
                  test = test)
  
  #split for 3 splits
  if(length(ratios)==3){
    
    # Get data sizes
    data_szs <- nrow(df) * ratios
    
    # Get train/valid ratio
    new_ratio <- data_szs[[1]]/(data_szs[[1]] + data_szs[[2]])
    
    # Get new splits
    res <- split_data(train, strat_var, ratios=c(new_ratio, 1-new_ratio))
    split_list <- list(train=res$train,
                    valid=res$test,
                    test = test)
  }
  else if (length(ratios)!=2){
    stop('You can only have 2 or 3 splits in the data.')
  }
  
  return(split_list)
}

```

```{r ranking and visualization}
# Unused for now
# Get total value based on placement of variable importance
get_total_placement <- function(list){
  # list: a list of data frames returned from the get_top_n_names function
  # returns: a data frame grouped by all variables with sum total of placement
  
  out <- list %>%
    purrr::reduce(rbind) %>% 
    group_by(variable) %>% 
    summarise(total = sum(placement))
  
  # return tibble
  return(out)
}



get_median_placement <- function(list, use_base_var = FALSE){
  # list: a list of data frames returned from the get_top_n_names function
  # use_base_var: a boolean indicating if you want to reduce a one-hot encoded name to its base name
  # returns: a data frame grouped by all variables with median of the placements of those variables
  
  if(use_base_var == TRUE){
    
    out <- list %>%
    purrr::reduce(rbind) %>%
    dplyr::rename(oh_var = variable)%>%
    mutate(variable = str_split(oh_var,'[.]', simplify=TRUE)[,1]) %>%
    group_by(variable) %>% 
    summarise(median_placement = median(placement))
    
  } else {
  out <- list %>%
    purrr::reduce(rbind) %>% 
    group_by(variable) %>% 
    summarise(median_placement = median(placement))
  }
  
  # return tibble
  return(out)
}
```

Both LASSO and RF can produce one-hot encoded variables/factors.  However, when we get the outputs, we need to be able to look up the variable and get the actual label that goes with it (e.g., 'FELT SAD').  This function puts those two things together - takes a variable like `h1fs1.3` , splits it into `h1fs1` and `3`, and then looks up the `h1fs1` in the ref_data.

```{r get attribute names}
#The purpose of this function is to get the attribute names from the one-hot encoded variable.  This is meant to be used with 
#a map_df function.
# var_str: input variable; can be a string, with or without the one-hot encoding
# ref_data: data which contains the labels for the variables. This could be full_dataset (dataset after joining waves)
# returns: a tibble with the lookup label
get_attribute_name <- function(var_str, ref_data){
  
  # split string
  res <- str_split(var_str, '[.]', simplify=TRUE)
  
  # Try to look up the variable
  lookup_name <- ref_data[[res[1,1]]]
  
  # If the lookup failed, return the original variable name.  Otherwise, return the label.
  if(is.null(lookup_name))
    att_name <- var_str
  else {
    # If no splitting was necessary (i.e. no one-hot encoding)
    if(length(res)==1) {
      att_name <- str_c(attributes(lookup_name))
    }
    else
      att_name <- str_c(attributes(lookup_name), '.', res[1,2])
  }
  
  # Return the name of interest.
  return(tibble(att_name))
}
```

```{r}
# function to plot a boxplot showing the variance in feature placements
plot_median_placements <- function(df_placements, top_n = 20){
  # input: df_placements - dataframe with all variables in model and their median placements from the models
  # ouput: barplot of the median placements
  
  df_placements <- df_placements %>%   
    mutate(top_x = if_else(median_placement <= top_n, paste0("Top ", top_n), paste0("Not Top ", top_n)))
  
  df_placements %>% 
    drop_na() %>% 
    arrange(desc(median_placement)) %>%
    ggplot(aes(x = reorder(variable, -median_placement), y = median_placement)) +
    geom_col(aes(fill = top_x)) +
    geom_hline(yintercept = top_n, color = "yellow") +
    xlab("Predictor Variable") + 
    ylab("Median Placement") +
    ggtitle("Median Variable Importance based on Bootstrap") +
    coord_flip() +
    theme_dark()
  
}

# function to plot a boxplot showing the variance in feature placements
plot_placement_boxplot <- function(placements){
  # input: list of placements from the bootstrapped samples
  # ouput: boxplot of placements of variables from the bootstraps
  
  
  combined_placements <- placements %>%
    purrr::reduce(rbind) %>% 
    drop_na()
  
  # Needs to be fixed so that axes don't overlap each other and obscure understanding
  combined_placements %>%
    group_by(variable)%>%
    ggplot() +
    geom_boxplot(aes(x = fct_reorder(variable, -placement), y = placement))+
    scale_x_discrete(expand = c(-0.001,0))+ 
    labs(y = "Placements", x = "Variables")+
    coord_flip()
  
}
```

```{r create splits for training and validating}

```

```{r build model}

```

